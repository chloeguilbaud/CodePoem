# Quand le code devient po√©sie...

‚è∞ Temps de lecture th√©orique estim√© : 30 min

‚è∞ Temps d'exercice pratique estim√© : 2h30

<!-- TOC -->
* [Quand le code devient po√©sie...](#quand-le-code-devient-po√©sie)
  * [Contexte de ce r√©po](#contexte-de-ce-r√©po)
    * [Ressources utiles](#ressources-utiles)
    * [Des questions ? Des retours ?](#des-questions--des-retours-)
    * [Pourquoi ce projet ?](#pourquoi-ce-projet-)
    * [Qu‚Äôallez-vous trouver ici ?](#quallez-vous-trouver-ici-)
    * [Vos premiers pas üõ†Ô∏è](#vos-premiers-pas-)
    * [Versions](#versions)
  * [Installation et Ex√©cution](#installation-et-ex√©cution)
    * [Pr√©requis](#pr√©requis)
    * [Installation](#installation)
    * [Ex√©cution](#ex√©cution)
    * [Jeux de donn√©es et üß™ Tests API avec Postman](#jeux-de-donn√©es-et--tests-api-avec-postman)
  * [Cas d'√©tude : Hi Shoes - "C'est pas beau, mais c'est pratique"](#cas-d√©tude--hi-shoes---cest-pas-beau-mais-cest-pratique)
    * [Domaine Principal (Core Domain) : La gestion des commandes](#domaine-principal-core-domain--la-gestion-des-commandes)
    * [Sous-domaines dans l'exemple](#sous-domaines-dans-lexemple)
    * [R√©partition par r√¥le vs par fonctionnalit√©](#r√©partition-par-r√¥le-vs-par-fonctionnalit√©)
    * [Concepts de DDD et Architecture Hexagonale](#concepts-de-ddd-et-architecture-hexagonale)
    * [Concepts abord√©s :](#concepts-abord√©s-)
* [ü™∂ Organisation du Code : Explorer les Concepts Cl√©s du DDD et de l'Architecture Hexagonale](#-organisation-du-code--explorer-les-concepts-cl√©s-du-ddd-et-de-larchitecture-hexagonale)
    * [1. `order/domain` : Le C≈ìur du Domaine M√©tier](#1-orderdomain--le-c≈ìur-du-domaine-m√©tier)
    * [2. `order/application` : Les Cas d‚ÄôUtilisation](#2-orderapplication--les-cas-dutilisation)
    * [3. `order/infrastructure` : Les Adaptateurs Techniques](#3-orderinfrastructure--les-adaptateurs-techniques)
    * [4. Packages Vides : Pr√©paration pour Facturation et Livraison](#4-packages-vides--pr√©paration-pour-facturation-et-livraison)
    * [Principes Cl√©s en Action](#principes-cl√©s-en-action)
  * [Passer √† la pratique : impl√©menter le domaine **`Facturation`** avec le DDD et l‚ÄôArchitecture Hexagonale](#passer-√†-la-pratique--impl√©menter-le-domaine-facturation-avec-le-ddd-et-larchitecture-hexagonale)
    * [Objectifs p√©dagogiques](#objectifs-p√©dagogiques)
    * [Contexte du projet](#contexte-du-projet)
    * [√Ä quoi t'attendre](#√†-quoi-tattendre)
* [ü™∂ Passer √† la pratique - exercice concret](#-passer-√†-la-pratique---exercice-concret)
  * [**Etape 1 : Comprendre l‚Äôimportance de la collaboration et de la langue d‚Äôubiquit√© Strategic Design**](#etape-1--comprendre-limportance-de-la-collaboration-et-de-la-langue-dubiquit√©-strategic-design)
    * [Contexte](#contexte)
    * [Pourquoi Strategic Design ?](#pourquoi-strategic-design-)
    * [D√©finir le domaine et ses sous-domaines](#d√©finir-le-domaine-et-ses-sous-domaines)
    * [Objectif p√©dagogique](#objectif-p√©dagogique)
    * [Actions pratiques](#actions-pratiques)
    * [Concepts DDD impliqu√©s](#concepts-ddd-impliqu√©s)
  * [√âtape 2 : Identifier les cas d‚Äôutilisation m√©tier](#√©tape-2--identifier-les-cas-dutilisation-m√©tier)
    * [Contexte](#contexte-1)
    * [Pourquoi identifier les cas d‚Äôutilisation dans une approche DDD‚ÄØ?](#pourquoi-identifier-les-cas-dutilisation-dans-une-approche-ddd)
    * [Exemple dans HiShoes ‚Äî Sous-domaine Facturation](#exemple-dans-hishoes--sous-domaine-facturation)
    * [Objectif p√©dagogique de l‚Äô√©tape](#objectif-p√©dagogique-de-l√©tape)
    * [Concepts DDD impliqu√©s](#concepts-ddd-impliqu√©s-1)
    * [**Actions pratiques**](#actions-pratiques-1)
    * [üéØ **M√©thodologie pour identifier les cas d‚Äôutilisation**](#-m√©thodologie-pour-identifier-les-cas-dutilisation)
    * [**Pi√®ges √† √©viter**](#pi√®ges-√†-√©viter)
  * [**√âtape 3 : Conceptualiser le mod√®le du domaine**](#√©tape-3--conceptualiser-le-mod√®le-du-domaine)
    * [**Contexte**](#contexte-2)
    * [**Pourquoi mod√©liser le domaine en DDD‚ÄØ?**](#pourquoi-mod√©liser-le-domaine-en-ddd)
    * [**Objectif p√©dagogique de l‚Äô√©tape**](#objectif-p√©dagogique-de-l√©tape-1)
    * [**M√©thodologie pour conceptualiser le mod√®le**](#m√©thodologie-pour-conceptualiser-le-mod√®le)
    * [1Ô∏è‚É£ **Identifier les concepts m√©tier stables et distincts**](#1-identifier-les-concepts-m√©tier-stables-et-distincts)
    * [2Ô∏è‚É£ **Classer ces concepts**](#2-classer-ces-concepts)
    * [3Ô∏è‚É£ **D√©finir les relations**](#3-d√©finir-les-relations)
    * [**R√©sultat attendu**](#r√©sultat-attendu)
    * [**Pi√®ges √† √©viter pour un d√©butant**](#pi√®ges-√†-√©viter-pour-un-d√©butant)
  * [√âtape 4 : Impl√©mentation du mod√®le](#√©tape-4--impl√©mentation-du-mod√®le)
    * [**Contexte**](#contexte-3)
    * [**Pourquoi impl√©menter le mod√®le avant tout autre chose ?**](#pourquoi-impl√©menter-le-mod√®le-avant-tout-autre-chose-)
    * [**Objectif p√©dagogique**](#objectif-p√©dagogique-1)
    * [**Exercice pratique et m√©thodologie**](#exercice-pratique-et-m√©thodologie)
    * [**Pi√®ges √† √©viter**](#pi√®ges-√†-√©viter-1)
  * [√âtape 5 : Cr√©ation des services du domaine](#√©tape-5--cr√©ation-des-services-du-domaine)
    * [**Contexte**](#contexte-4)
    * [**Pourquoi cr√©er des services de domaine en DDD ?**](#pourquoi-cr√©er-des-services-de-domaine-en-ddd-)
    * [**Objectif p√©dagogique**](#objectif-p√©dagogique-2)
    * [**Quand cr√©er un service de domaine ?**](#quand-cr√©er-un-service-de-domaine-)
    * [**Passer √† la pratique : Facturation de HiShoes**](#passer-√†-la-pratique--facturation-de-hishoes)
    * [**R√©sultat attendu**](#r√©sultat-attendu-1)
    * [**Pi√®ges √† √©viter pour un d√©butant**](#pi√®ges-√†-√©viter-pour-un-d√©butant-1)
  * [√âtape 6 : Impl√©mentation des cas d‚Äôutilisation ‚Äî Pattern Command / Query](#√©tape-6--impl√©mentation-des-cas-dutilisation--pattern-command--query)
    * [**Pourquoi utiliser un pattern Command / Query ?**](#pourquoi-utiliser-un-pattern-command--query-)
    * [**Objectif p√©dagogique**](#objectif-p√©dagogique-3)
    * [üåü **Explication du pattern Command / Query dans le contexte DDD**](#-explication-du-pattern-command--query-dans-le-contexte-ddd)
    * [**Command : exprimer une intention**](#command--exprimer-une-intention)
    * [**Query : fournir des informations pour guider une d√©cision**](#query--fournir-des-informations-pour-guider-une-d√©cision)
    * [**Vision compl√©mentaire : le dialogue Command / Query**](#vision-compl√©mentaire--le-dialogue-command--query)
    * [**Pourquoi ce pattern est utile ?**](#pourquoi-ce-pattern-est-utile-)
    * [**Exercice pratique**](#exercice-pratique)
    * [**R√©sultat attendu**](#r√©sultat-attendu-2)
    * [**Pi√®ges √† √©viter**](#pi√®ges-√†-√©viter-2)
  * [**√âtape 7 : Ports et adaptateurs sortants**](#√©tape-7--ports-et-adaptateurs-sortants)
    * [**Contexte**](#contexte-5)
    * [**Pourquoi des ports et adaptateurs ?**](#pourquoi-des-ports-et-adaptateurs-)
    * [**Objectif p√©dagogique**](#objectif-p√©dagogique-4)
    * [Passer √† la pratique](#passer-√†-la-pratique)
    * [**R√©sultat attendu**](#r√©sultat-attendu-3)
    * [**Pi√®ges √† √©viter pour un d√©butant**](#pi√®ges-√†-√©viter-pour-un-d√©butant-2)
  * [**√âtape finale : Assemblage et test de bout en bout**](#√©tape-finale--assemblage-et-test-de-bout-en-bout)
    * [**Contexte**](#contexte-6)
    * [**Objectif p√©dagogique**](#objectif-p√©dagogique-5)
* [ü™∂ **R√©sultat attendu ou proposition de compr√©hension du domaine m√©tier de l‚Äôentreprise**](#-r√©sultat-attendu-ou-proposition-de-compr√©hension-du-domaine-m√©tier-de-lentreprise)
  * [√âtape 1 : Comprendre l‚Äôimportance de la collaboration et de la langue d‚Äôubiquit√© (Strategic Design)](#√©tape-1--comprendre-limportance-de-la-collaboration-et-de-la-langue-dubiquit√©-strategic-design)
  * [√âtape 2 : Identifier les cas d‚Äôutilisation m√©tier](#√©tape-2--identifier-les-cas-dutilisation-m√©tier-1)
    * [**Cas d‚Äôutilisation identifi√©s pour HiShoes ‚Äî Facturation**](#cas-dutilisation-identifi√©s-pour-hishoes--facturation)
    * [**R√©sultat attendu**](#r√©sultat-attendu-4)
    * [**Exemple de cas d‚Äôutilisation : Cr√©er une facture pour une commande valid√©e**](#exemple-de-cas-dutilisation--cr√©er-une-facture-pour-une-commande-valid√©e)
    * [**Nom du cas d‚Äôutilisation**](#nom-du-cas-dutilisation)
    * [**Objectif**](#objectif)
    * [**Acteurs principaux**](#acteurs-principaux)
    * [**Pr√©-condition**](#pr√©-condition)
    * [**D√©clencheur**](#d√©clencheur)
    * [**Description du sc√©nario principal**](#description-du-sc√©nario-principal)
    * [**R√®gles m√©tier**](#r√®gles-m√©tier)
    * [**Exceptions**](#exceptions)
    * [**Post-condition**](#post-condition)
    * [**Donn√©es manipul√©es**](#donn√©es-manipul√©es)
    * [**Langue d‚Äôubiquit√© utilis√©e**](#langue-dubiquit√©-utilis√©e)
    * [**√âtape 3 : Conceptualiser le mod√®le du domaine**](#√©tape-3--conceptualiser-le-mod√®le-du-domaine-1)
    * [Agr√©gat racine : **Facture (Invoice)**](#agr√©gat-racine--facture-invoice)
    * [Entit√©s et objets de valeur](#entit√©s-et-objets-de-valeur)
    * [**R√®gles m√©tier int√©gr√©es au mod√®le**](#r√®gles-m√©tier-int√©gr√©es-au-mod√®le)
  * [√âtape 4 : Impl√©mentation du mod√®le](#√©tape-4--impl√©mentation-du-mod√®le-1)
    * [1Ô∏è‚É£ **Commence par les objets de valeur**](#1-commence-par-les-objets-de-valeur)
    * [2Ô∏è‚É£ **Code l‚Äôagr√©gat racine**](#2-code-lagr√©gat-racine)
    * [3Ô∏è‚É£ **Impl√©mente les autres entit√©s / VO**](#3-impl√©mente-les-autres-entit√©s--vo)
  * [Notion importante : l‚Äôobjet est garant de son int√©grit√©](#notion-importante--lobjet-est-garant-de-son-int√©grit√©)
    * [**Mauvaise approche (la r√®gle est laiss√©e au code ext√©rieur)**](#mauvaise-approche-la-r√®gle-est-laiss√©e-au-code-ext√©rieur)
    * [**Bonne approche (le mod√®le garantit lui-m√™me son int√©grit√©)**](#bonne-approche-le-mod√®le-garantit-lui-m√™me-son-int√©grit√©)
  * [√âtape 5 : Cr√©ation des services du domaine](#√©tape-5--cr√©ation-des-services-du-domaine-1)
    * [**Exemple de code (Java / pseudo code simplifi√©)**](#exemple-de-code-java--pseudo-code-simplifi√©)
  * [√âtape 6 : Impl√©mentation des cas d‚Äôutilisation ‚Äî Pattern Command / Query](#√©tape-6--impl√©mentation-des-cas-dutilisation--pattern-command--query-1)
    * [**Structure type d‚Äôun cas d‚Äôutilisation**](#structure-type-dun-cas-dutilisation)
    * [**Exemple concret : cr√©er une facture (Command)**](#exemple-concret--cr√©er-une-facture-command)
    * [üìù **Command**](#-command)
    * [üìù **CommandHandler**](#-commandhandler)
    * [**Exemple concret : retrouver une facture (Query)**](#exemple-concret--retrouver-une-facture-query)
    * [üìù **Query**](#-query)
    * [üìù **QueryHandler**](#-queryhandler)
  * [√âtape 7 : Ports et adaptateurs sortants](#√©tape-7--ports-et-adaptateurs-sortants-1)
    * [**Exemple concret : Facturation HiShoes**](#exemple-concret--facturation-hishoes)
    * [**Port : `InvoiceRepository`**](#port--invoicerepository)
    * [**Port : `PaymentProcessor` (exemple optionnel)**](#port--paymentprocessor-exemple-optionnel)
    * [**Adaptateur sortant : une impl√©mentation de `InvoiceRepository`**](#adaptateur-sortant--une-impl√©mentation-de-invoicerepository)
  * [√âtape finale : Assemblage et test de bout en bout](#√©tape-finale--assemblage-et-test-de-bout-en-bout-1)
    * [1Ô∏è‚É£ **Adaptateurs entrants : exposer les cas d‚Äôutilisation**](#1-adaptateurs-entrants--exposer-les-cas-dutilisation)
    * [2Ô∏è‚É£ **Assembler les ports et adaptateurs**](#2-assembler-les-ports-et-adaptateurs)
    * [3Ô∏è‚É£ **√âcrire un test de bout en bout**](#3-√©crire-un-test-de-bout-en-bout)
* [ü™∂ Evolutions](#-evolutions)
* [ü™∂ **Des questions ? Des retours ?**](#-des-questions--des-retours-)
<!-- TOC -->

## Contexte de ce r√©po

Dans le monde de la technologie, ma√Ætriser quelques concepts cl√©s peut faire toute la diff√©rence entre un bon¬∑ne d√©veloppeur¬∑euse et un¬∑e d√©veloppeur¬∑euse exceptionnel¬∑le. Les design patterns sont ces concepts essentiels qui vous permettront de produire des applications de haute qualit√©, faciles √† maintenir et √† faire √©voluer. Vous n‚Äôavez pas besoin de conna√Ætre tous les design patterns. Un ou deux peuvent suffire, et aujourd‚Äôhui je vous propose de d√©couvrir l‚Äôarchitecture hexagonale et le Domain Driven Design.

Que vous soyez un¬∑e novice intr√©pide ou un¬∑e v√©t√©ran¬∑e chevronn√©¬∑e de la tech, l‚Äôarchitecture hexagonale permet d'√©viter les pi√®ges et les √©cueils lorsque plusieurs d√©veloppeurs collaborent sur un m√™me projet.

Alors je vous propose une courte session pour transformer vos lignes de code en v√©ritable po√©sie‚Ä¶

Ce r√©po git vient en support pratique de la conf√©rence ["Quand le code devient po√©sie..."](https://hiweb.fr/conference-quand-le-code-devient-poesie) de [Chlo√© Guilbaud](https://hiweb.fr/conference/linkedin), co-fondatrice du collectif de freelance [Hi Web!](https://hiweb.fr).
Pour consulter la description compl√®te de la conf√©rence : [Quand le code devient po√©sie...](https://hiwebfr.notion.site/CFP-Quand-le-code-devient-po-sie-2d275dfff6744a0482c2b2310a0dde83?source=copy_link).

### Ressources utiles
Parce que la connaissance seule ne suffit pas : c‚Äôest en pratiquant qu‚Äôon progresse vraiment. Apr√®s la conf√©rence, je vous invite √† plonger dans le code‚ÄØ! Et pour cela, je vous offre un petit cadeau : un r√©pertoire Git et des ressources pour continuer √† explorer et exp√©rimenter par vous-m√™me.
- Ce r√©pertoire Git : un ensemble d‚Äôexemples pratiques et de projets que chacun¬∑e peut explorer et adapter. Rien de tel que de mettre les mains dans le code pour bien assimiler les concepts.
- [La cheat sheet](https://hiweb.fr/conference/quand-le-code-devient-poesie/form) : un guide rapide qui regroupe l‚Äôessentiel des concepts et des bonnes pratiques, pour vous aider √† les appliquer plus facilement.
- [La description de la conf√©rence Quand le code devient po√©sie...](https://hiwebfr.notion.site/CFP-Quand-le-code-devient-po-sie-2d275dfff6744a0482c2b2310a0dde83?source=copy_link) : pour retrouver le fil conducteur de la session et prolonger la r√©flexion. 
- [Article de blog](https://hiweb.fr/conference-quand-le-code-devient-poesie) : Retrouvez un r√©capitulatif complet, les actualit√©s sur le sujet, et tous les supports de la conf√©rence.
- üëâ N‚Äôh√©sitez pas √† forker le projet, √† tester, √† modifier et √† partager vos id√©es : c‚Äôest en exp√©rimentant qu‚Äôon apprend le mieux‚ÄØ!

### Des questions ? Des retours ?

Je serais ravie d‚Äô√©changer avec vous sur vos exp√©riences, vos questions, ou vos suggestions pour am√©liorer ce projet.

üìß **Contactez-moi** : Chlo√© Guilbaud

üîó **Retrouvez-moi sur LinkedIn** : [Chlo√© Guilbaud](https://www.linkedin.com/in/chloeguilbaud/)

### Pourquoi ce projet ?

Lors de la conf√©rence ‚ÄúQuand le code devient po√©sie‚Ä¶‚Äù, nous avons explor√© ensemble les concepts cl√©s du **DDD** et comment cette approche, associ√©e √† une architecture hexagonale, peut transformer votre mani√®re de concevoir des logiciels. Mais apprendre ces concepts en th√©orie, c‚Äôest une chose. Les **mettre en pratique**, c‚Äôen est une autre !

Ce projet est con√ßu pour :

- **D√©mystifier le DDD** gr√¢ce √† un exemple concret : une boutique de vente en ligne de chaussures, les HiShoes ü•ø. Le slogan de la boutique : ¬´¬†c‚Äôest pas beau, mais c‚Äôest pratique¬†¬ª
- **Explorer l‚Äôarchitecture hexagonale** en manipulant du code organis√© autour des ports et des adaptateurs.
- Vous permettre de **mettre les mains dans le code** et d‚Äôappliquer ces concepts dans des situations r√©elles.

### Qu‚Äôallez-vous trouver ici ?

- Un **exemple d‚Äôapplication** qui illustre des concepts tels que :
    - **Entit√©s, Value Objects et Domain Events**
    - **Bounded Contexts et Use Cases**
    - **Ports et Adaptateurs** dans une architecture hexagonale
- Des exercices pour exp√©rimenter, adapter et am√©liorer le projet.
- Une organisation de code qui suit les bonnes pratiques pour faciliter votre apprentissage.

### Vos premiers pas üõ†Ô∏è

Plongez dans le projet, suivez les instructions, et explorez les diff√©rents modules. Tout est con√ßu pour vous guider et vous permettre d‚Äôexp√©rimenter par vous-m√™me. N‚Äôh√©sitez pas √† casser, corriger, et r√©inventer le code.

#szsz# Couche technique

Ce projet est d√©velopp√© en **Java** avec les frameworks et outils suivants :

- **Maven** : pour la gestion des d√©pendances et le cycle de vie du projet.
- **Spring Boot** : pour simplifier le d√©veloppement d'applications bas√©es sur Spring, notamment gr√¢ce √† ses fonctionnalit√©s comme l'injection de d√©pendances, la gestion des configurations, et les d√©marrages rapides.

### Versions

- Java : `23`
- Maven : `4.0.O`
- Spring Boot : `3.3.4`

## Installation et Ex√©cution

### Pr√©requis

Assures toi d'avoir les √©l√©ments suivants install√©s sur votre machine :

- **Java** (JDK 11 ou sup√©rieur, selon la configuration de votre projet)
- **Maven** (version 3.x ou sup√©rieure)
- (Optionnel) Un IDE compatible avec Maven (comme IntelliJ IDEA, Eclipse ou VS Code)

### Installation

1. **Cloner le d√©p√¥t :**

    ```bash
    git clone <URL_DU_DEPOT>
    cd <NOM_DU_PROJET>
    
    ```

2. **Installer les d√©pendances et compiler le projet :**
   Utilisez la commande Maven suivante pour nettoyer, compiler et installer les d√©pendances :

    ```bash
    mvn clean install
    
    ```


### Ex√©cution

1. **Lancer l'application :**
   Avec Maven, vous pouvez ex√©cuter l'application directement en utilisant le plugin Spring Boot :

    ```bash
    mvn spring-boot:run
    
    ```

   Ou si l'application a √©t√© empaquet√©e (par exemple en `.jar`) :

    ```bash
    java -jar target/<NOM_DU_JAR>.jar
    
    ```

### Jeux de donn√©es et üß™ Tests API avec Postman

Un dossier `postman/` contient des **jeux de requ√™tes Postman** permettant de tester rapidement l‚ÄôAPI REST expos√©e par cette application.

**Emplacement :**

```
src/test/resources/postman/
```

**Contenu :**

`codepoeme.postman-collection.json`
- hello world `POST /hello`
- exemples de requ√™tes `POST /invoice`, `GET /invoices`
- commandes d'achat de hiShoes `POST /order`

**Comment les utiliser :**

1. Ouvre Postman
2. Clique sur **Importer** (`File > Import` ou ic√¥ne "+" ‚Üí **Import**)
3. S√©lectionne le fichier `.json` dans `src/test/resources/postman/`
4. Laisse Postman importer la collection
5. Ex√©cute les requ√™tes (v√©rifie que le backend est bien d√©marr√© sur `localhost:8080`)


## Cas d'√©tude : Hi Shoes - "C'est pas beau, mais c'est pratique"

Dans cette conf√©rence, nous explorons un cas d'√©tude concret autour de la boutique en ligne **Hi Shoes**, une entreprise qui vend des chaussures pratiques et fonctionnelles, avec un slogan qui r√©sume parfaitement leur concept :

**"C'est pas beau, mais c'est pratique"**.

### Domaine Principal (Core Domain) : La gestion des commandes

Le c≈ìur de l'application se concentre sur la gestion des commandes de chaussures **Hi Shoes**. Le **core domain** repose sur des concepts cl√©s permettant de suivre les actions essentielles li√©es aux commandes, aux clients et aux produits (les HiShoes). Nous appliquons les principes de **Domain-Driven Design (DDD)** et l'**architecture hexagonale** pour mod√©liser et isoler la logique m√©tier des autres pr√©occupations techniques.

### Sous-domaines dans l'exemple

Dans cet exemple, nous avons simplifi√© les choses en d√©finissant trois sous-domaines distincts, correspondant √† des r√¥les dans le processus de vente des HiShoes :

1. **Order (Gestion des commandes)** :
    - Ce sous-domaine traite de la cr√©ation et de l'enregistrement des commandes de chaussures.
    - Il inclut des entit√©s comme **Order** (commande), avec des **events** comme `OrderHasBeenCreated`, et des services m√©tier comme `CreateOrderService` pour la gestion des commandes.
2. **Facturation (Billing)** :
    - Ce sous-domaine est responsable de la g√©n√©ration et de l'enregistrement des factures li√©es aux commandes pass√©es par les clients.
    - Bien que ce sous-domaine ne soit pas encore impl√©ment√© dans cet exemple, il pourrait inclure des services comme **`InvoiceService`** et des entit√©s comme **`Invoice`**.
3. **Livraison (Shipping)** :
    - Ce sous-domaine g√®re l'acheminement des commandes une fois qu'elles sont enregistr√©es et factur√©es.
    - Il pourrait inclure des services comme **`ShippingService`** et des entit√©s comme **`Shipment`**, repr√©sentant les informations de livraison li√©es √† chaque commande.

### R√©partition par r√¥le vs par fonctionnalit√©

Dans cet exemple, nous avons fait le choix de structurer le code en **sous-domaines par r√¥le**, c'est-√†-dire en cr√©ant des packages s√©par√©s pour chaque fonction ou d√©partement comme `order`, `facturation` et `livraison`. Ce d√©coupage est simple √† comprendre et peut convenir pour des syst√®mes petits ou avec des √©quipes qui ont des responsabilit√©s claires et bien s√©par√©es.

Cependant, dans un v√©ritable projet √† grande √©chelle, il est g√©n√©ralement pr√©f√©rable d'opter pour un **d√©coupage par fonctionnalit√©**, afin de mieux refl√©ter les **fonctionnalit√©s m√©tiers** transverses et d'encourager une meilleure collaboration entre les √©quipes. Cela permet aussi d'√©viter des d√©pendances trop fortes entre les sous-domaines. Voici un exemple de d√©coupage par fonctionnalit√© :

- **Gestion des commandes** : Ce module regroupe √† la fois la cr√©ation de la commande, la facturation et la gestion de la livraison en un seul ensemble fonctionnel. Par exemple, une fonctionnalit√© **"Passer une commande"** pourrait inclure le processus complet de commande, paiement et exp√©dition.
- **Gestion des clients** : Ce module pourrait inclure l'enregistrement des clients, la mise √† jour des informations de contact et l'historique des commandes, mais aussi la gestion des r√©ductions ou des programmes de fid√©lit√©.

Ce type de d√©coupage par fonctionnalit√© permettrait une plus grande autonomie des √©quipes et une flexibilit√© accrue pour g√©rer les √©volutions du syst√®me.

### Concepts de DDD et Architecture Hexagonale

Nous appliquons une **architecture hexagonale** pour isoler le domaine m√©tier des d√©pendances techniques. Voici un rappel des concepts utilis√©s :

- **Core Domain** : La logique m√©tier essentielle, repr√©sent√©e par des **entit√©s**, des **values objects** et des **services** m√©tier.
- **Bounded Context** : Chaque sous-domaine est mod√©lis√© et isol√© √† l'int√©rieur d'un contexte bien d√©fini, √©vitant ainsi les interf√©rences avec d'autres sous-domaines.
- **Ports et Adapters** : Nous exposons des **ports** (interfaces) pour la communication avec l'ext√©rieur (API REST dans notre cas avec `OrderController`) et les **adapters** qui fournissent les impl√©mentations concr√®tes (comme les repositories en m√©moire).

L'application est construite de mani√®re √† s√©parer les pr√©occupations li√©es √† la logique m√©tier et les aspects techniques, permettant ainsi une meilleure compr√©hension du domaine et une flexibilit√© accrue pour √©voluer et ajouter de nouvelles fonctionnalit√©s.

### Concepts abord√©s :

- **DDD ‚Äì Domain-Driven Design** : Comprendre le domaine m√©tier, les mod√®les riches, les Use Cases, et la langue d‚Äôubiquit√©.

![codepoeme-illustration-ddd.png](src/main/resources/doc/image/codepoeme-illustration-ddd.png)

- **Architecture hexagonale** : Isolation de la logique m√©tier, ports et adaptateurs, s√©paration des pr√©occupations entre domaine et infrastructure.

![codepoeme-illustration-archihexa.png](src/main/resources/doc/image/codepoeme-illustration-archihexa.png)

Ces ressources sont con√ßues pour prolonger votre apprentissage et vous encourager √† exp√©rimenter avec le code. Si vous avez des questions ou souhaitez √©changer des id√©es, je suis toujours ravie de discuter ‚Äî connectez-moi sur [LinkedIn](https://www.linkedin.com/in/chloeguilbaud/) !

# ü™∂ Organisation du Code : Explorer les Concepts Cl√©s du DDD et de l'Architecture Hexagonale

Ce projet est structur√© selon les principes du **DDD** et de l‚Äô**architecture hexagonale**. Cette organisation a pour but de s√©parer les pr√©occupations (logique m√©tier, infrastructure technique, etc.) pour rendre le code plus compr√©hensible, maintenable et extensible.

Voici une description des principaux packages :

```markdown
üì¶ hiweb.codepoem
‚îî‚îÄ‚îÄ üì¶ order
    ‚îú‚îÄ‚îÄ üìÇ domain                    # C≈ìur m√©tier (Domain)
    ‚îÇ   ‚îú‚îÄ‚îÄ üìÇ model                 # Mod√®les du domaine
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ Client.java           # Entit√© Client
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ HiShoe.java           # Entit√© HiShoe
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ HiShoe_COLOR.java     # Value Object pour la couleur (ex : RGB)
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ HiShoe_MODEL.java     # Value Object pour le mod√®le
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ Order.java            # Aggregate Root pour les commandes
    ‚îÇ   ‚îÇ
    ‚îÇ   ‚îú‚îÄ‚îÄ üìÇ events                 # √âv√©nements de domaine
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ OrderHasBeenCreated.java # √âv√©nement d√©clench√© lorsqu'une commande est cr√©√©e
    ‚îÇ   ‚îÇ
    ‚îÇ   ‚îú‚îÄ‚îÄ üìÇ exception             # Exceptions du domaine
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ InvalidShoeSizeException.java  # Exception pour tailles invalides
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ HiShoeNotFoundException.java   # Exception pour chaussures introuvables
    ‚îÇ   ‚îÇ
    ‚îÇ   ‚îú‚îÄ‚îÄ üìÇ service               # Services m√©tier
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ CreateOrderService.java       # Service m√©tier pour la cr√©ation de commande
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ DiscountCalculatorService.java # Service m√©tier pour les calculs de r√©duction
    ‚îÇ   ‚îÇ
    ‚îÇ   ‚îî‚îÄ‚îÄ üìÇ port                  # Ports pour les interfaces
    ‚îÇ       ‚îú‚îÄ‚îÄ üìÇ usecase           # Cas d‚Äôutilisation
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ RegisterOrderCommand.java  # Commande pour enregistrer une commande
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ RegisterOrderUseCase.java  # Interface d√©finissant le cas d‚Äôutilisation
    ‚îÇ       ‚îÇ
    ‚îÇ       ‚îú‚îÄ‚îÄ üìÇ repository        # Interfaces des repositories
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ ClientRepository.java      # Interface pour g√©rer les clients
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ HiShoeRepository.java      # Interface pour g√©rer les HiShoes
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ OrderRepository.java       # Interface pour g√©rer les commandes
    ‚îÇ       ‚îÇ
    ‚îÇ       ‚îî‚îÄ‚îÄ üìÇ dispatcher        # Interface pour la gestion des √©v√©nements
    ‚îÇ           ‚îî‚îÄ‚îÄ üìÑ EventDispatcher.java       # Interface pour dispatcher les √©v√©nements
    ‚îÇ
    ‚îú‚îÄ‚îÄ üìÇ application               # Couche Application
    ‚îÇ   ‚îî‚îÄ‚îÄ üìÇ controllers           # Contr√¥leurs exposant l'application
    ‚îÇ       ‚îî‚îÄ‚îÄ üìÑ OrderController.java # Contr√¥leur pour g√©rer les commandes (REST API)
    ‚îÇ
    ‚îú‚îÄ‚îÄ üìÇ infrastructure            # Adaptateurs techniques (Infrastructure Layer)
    ‚îÇ   ‚îú‚îÄ‚îÄ üìÇ repository            # Impl√©mentations des repositories (stockage des donn√©es)
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ InMemoryClientRepository.java   # Repository pour les clients (en m√©moire)
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ InMemoryHiShoeRepository.java   # Repository pour les chaussures (en m√©moire)
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ InMemoryOrderRepository.java    # Repository pour les commandes (en m√©moire)
    ‚îÇ   ‚îÇ
    ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ EventDispatcherImpl.java           # Impl√©mentation concr√®te de l‚Äôinterface EventDispatcher
    ‚îÇ
    ‚îú‚îÄ‚îÄ üìÇ facturation               # Package r√©serv√© pour la facturation (vide pour l‚Äôinstant)
    ‚îî‚îÄ‚îÄ üìÇ livraison                 # Package r√©serv√© pour la livraison (vide pour l‚Äôinstant)

```

### 1. `order/domain` : Le C≈ìur du Domaine M√©tier

C‚Äôest ici que r√©side toute la **logique m√©tier**. Cette couche est **ind√©pendante des technologies** et repr√©sente les r√®gles, concepts et invariants propres √† la boutique HiShoes.

**Contenu** :

- **Mod√®les M√©tier** :
    - **Entit√©s** comme `Client`, `HiShoe`, et `Order` qui capturent les caract√©ristiques principales de chaque concept.
    - **Value Objects** comme `HiShoe_COLOR` ou `HiShoe_MODEL`, pour repr√©senter des valeurs immuables li√©es aux chaussures.
    - **Aggr√©gats** : L‚Äôentit√© `Order` agit comme **Aggregate Root**, garantissant la coh√©rence des op√©rations sur les commandes.
- **Services M√©tier** :
    - `CreateOrderService` : Contient les r√®gles pour cr√©er une commande.
    - `DiscountCalculatorService` : G√®re les calculs li√©s aux r√©ductions.
- **√âv√©nements de Domaine** :
    - `OrderHasBeenCreated` : Repr√©sente un √©v√©nement significatif du domaine.
- **Exceptions M√©tier** :
    - `InvalidShoeSizeException` ou `HiShoeNotFoundException` pour capturer des erreurs sp√©cifiques au domaine.
- **Ports pour les Use Cases** :
    - `RegisterOrderCommand` : Repr√©sente les donn√©es n√©cessaires pour cr√©er une commande.
    - `RegisterOrderUseCase` : D√©finit l‚Äôinterface pour ex√©cuter ce cas d‚Äôutilisation.
- **Ports pour la couche technique** :
    - `ClientRepository` : D√©finit l‚Äôinterface pour la persistance `Client`.
    - `HiShoeRepository` : D√©finit l‚Äôinterface pour la persistance `HiShoe`.
    - `OrderRepository` : D√©finit l‚Äôinterface pour la persistance `Order`.

**Lien avec les principes du DDD** :

- Cette couche se concentre sur le **domaine m√©tier**.
- Les mod√®les sont riches en comportement, favorisant un code **orient√© m√©tier** et non centr√© sur les donn√©es.

### 2. `order/application` : Les Cas d‚ÄôUtilisation

Ce package expose les **cas d‚Äôutilisation** qui traduisent les intentions m√©tier en actions concr√®tes.

**Contenu** :

- **Contr√¥leurs** :
    - `OrderController` : Interface d‚Äôentr√©e expos√©e via une API HTTP.
    - Ce contr√¥leur traduit les requ√™tes utilisateur en commandes pour les **Use Cases**.

**Lien avec les principes de l‚Äôarchitecture hexagonale** :

- Cette couche repr√©sente le **Driver Side** (ou c√¥t√© entrant).
- Elle orchestre les interactions entre l‚Äôutilisateur et la logique m√©tier via des **ports**.
- Application du pattern Command/Query.

### 3. `order/infrastructure` : Les Adaptateurs Techniques

Cette couche g√®re les aspects techniques et l‚Äôint√©gration avec les syst√®mes externes.

**Contenu** :

- **Adaptateurs pour les Repositories** :
    - `InMemoryClientRepository`, `InMemoryHiShoeRepo`, `InMemoryOrderRepo` : Impl√©mentations en m√©moire pour stocker temporairement les donn√©es.
- **Event Dispatcher** (futur d√©veloppement) :
    - Pour publier et propager les **Domain Events** dans d‚Äôautres parties du syst√®me.

**Lien avec les principes de l‚Äôarchitecture hexagonale** :

- Cette couche repr√©sente le **Driven Side** (ou c√¥t√© sortant).
- Les adaptateurs techniques impl√©mentent les interfaces d√©finies dans le domaine (`ClientRepository`, `OrderRepository` et `HiShoeRepository`) pour garantir une ind√©pendance vis-√†-vis des technologies.

### 4. Packages Vides : Pr√©paration pour Facturation et Livraison

- **`order/billing`** et **`order/shipping`** sont des **contextes potentiels** √† d√©velopper.
- Chacun de ces contextes pourrait devenir un **Bounded Context** distinct avec ses propres mod√®les m√©tier, ports, et adaptateurs.

**Lien avec les principes DDD** :

- La s√©paration en contextes permet de respecter les **Bounded Contexts** et d‚Äô√©viter un mod√®le global trop complexe.

### Principes Cl√©s en Action

1. **S√©paration des pr√©occupations** :
    - Le domaine m√©tier est **isol√©** des d√©tails techniques.
    - Les cas d‚Äôutilisation orchestrent les interactions.
    - L‚Äôinfrastructure est interchangeable et encapsul√©e.
2. **Ports et Adaptateurs** :
    - Les **ports** d√©finissent les interfaces pour les use cases et les services techniques (comme les repositories).
    - Les **adaptateurs** fournissent des impl√©mentations concr√®tes de ces interfaces.
3. **Ind√©pendance Technologique** :
    - Toute la logique m√©tier peut √™tre test√©e sans d√©pendre des frameworks ou de la base de donn√©es.
4. **Ubiquitous Language** :
    - Le code refl√®te directement les termes du domaine m√©tier, ce qui favorise une compr√©hension partag√©e entre d√©veloppeuses et expertes m√©tier.

## Passer √† la pratique : impl√©menter le domaine **`Facturation`** avec le DDD et l‚ÄôArchitecture Hexagonale

Bienvenue dans cet exercice consacr√© √† la **gestion de la facturation** pour la boutique en ligne **Hi Shoes**. Cet exercice est con√ßu pour te permettre de d√©couvrir et d'appliquer les principes fondamentaux du **Domain-Driven Design (DDD)** et de l'**architecture hexagonale** √† travers un cas concret et pratique.

Hi Shoes est une entreprise qui vend des chaussures pratiques et fonctionnelles. Leur slogan est simple et percutant : **"C'est pas beau, mais c'est pratique"**. Dans cet exercice, tu travailleras sur un des aspects cl√©s de leur syst√®me : la gestion des commandes et, plus sp√©cifiquement, la gestion de la facturation.

### Objectifs p√©dagogiques

L'objectif de cet exercice est de te guider dans la cr√©ation d'une partie du syst√®me de facturation en appliquant les concepts du DDD et de l'architecture hexagonale. √Ä travers l'impl√©mentation des cas d'utilisation **`CreateInvoiceUseCase`** et **`PayInvoiceUseCase`**, tu apprendras √† :

- **Mod√©liser un domaine** en DDD en cr√©ant des entit√©s, des objets de valeur et des agr√©gats.
- **S√©parer les responsabilit√©s** de l'application √† travers une architecture hexagonale, en d√©finissant des ports et des adaptateurs pour g√©rer l'interaction avec le monde ext√©rieur.
- **R√©aliser des cas d'utilisation** qui incarnent les r√®gles m√©tiers d'un domaine, en respectant les bonnes pratiques de conception.

L'exercice est con√ßu pour √™tre accessible m√™me si tu d√©butes en DDD et en architecture hexagonale. Tu apprendras en √©crivant du code et en d√©couvrant comment structurer une application de mani√®re propre et √©volutive.

### Contexte du projet

Dans l'exemple de l'application Hi Shoes, nous avons d√©j√† les sous-domaines de **Gestion des commandes (Order)** et de **Livraison (Shipping)**. Nous allons maintenant ajouter le sous-domaine **Facturation (Billing)** qui g√®re la cr√©ation des factures pour chaque commande pass√©e par un client.

La gestion des factures chez Hi Shoes doit permettre de cr√©er des factures √† partir des commandes pass√©es par les clients et de traiter les paiements associ√©s. Le domaine de la facturation est en pleine √©volution, et c'est l√† que tu interviens pour am√©liorer et impl√©menter deux cas d'utilisation majeurs : **la cr√©ation de factures** et **le paiement des factures**.

### √Ä quoi t'attendre

Au fur et √† mesure de cet exercice, tu seras amen√© √† impl√©menter des parties essentielles de la logique m√©tier, tout en respectant une architecture claire et modulable. Tu exploreras un projet qui est √† la fois flexible et robuste, et tu verras comment appliquer des pratiques de d√©veloppement durable et coh√©rentes.

Pr√©pare-toi √† mettre les mains dans le code et √† r√©fl√©chir √† la structure du domaine. Cet exercice est une excellente occasion d‚Äôapprofondir tes comp√©tences en architecture logicielle et d‚Äôacqu√©rir une compr√©hension solide des principes du DDD et de l'architecture hexagonale.

# ü™∂ Passer √† la pratique - exercice concret

Pour chaque √©tape, je t‚Äôinvite vivement √† t√© r√©f√©rer √† la cheatsheet et pour rappel tu trouveras une proposition d‚Äôimplementation dans le package : `billing.implementation.exemple`. 

## **Etape 1 : Comprendre l‚Äôimportance de la collaboration et de la langue d‚Äôubiquit√© Strategic Design**

### Contexte

Tu viens d‚Äôint√©grer une √©quipe qui d√©veloppe le syst√®me de gestion des commandes et des factures pour la boutique en ligne **HiShoes**, sp√©cialis√©e dans la vente de chaussures.

üëâ Une difficult√© freine le projet : les d√©veloppeurs et les experts m√©tier utilisent des mots diff√©rents pour parler des m√™mes concepts, ce qui cr√©e des malentendus et des erreurs de mod√©lisation.

Ta premi√®re mission : poser les bases d‚Äôune **langue d‚Äôubiquit√©** ‚Äî un vocabulaire commun partag√© par toutes les parties prenantes (m√©tier + tech).

Ce langage commun :

- facilite la communication au quotidien,
- guide la mod√©lisation des concepts m√©tier,
- aligne la technologie avec les besoins r√©els de l‚Äôentreprise.

### Pourquoi Strategic Design ?

Quand on construit une architecture en *Domain-Driven Design* (DDD), la premi√®re √©tape consiste √† :

‚úÖ **R√©unir les experts m√©tier et les experts techniques autour de la table**.

‚úÖ **Se mettre d‚Äôaccord sur le fonctionnement d‚Äôune partie pr√©cise de l‚Äôentreprise (le domaine)**.

C‚Äôest ce qu‚Äôon appelle le **Strategic Design** :

üëâ Le but n‚Äôest pas de faire un consensus sur tout, mais que les membres concern√©s par un m√™me sous-domaine parlent la m√™me langue.

### D√©finir le domaine et ses sous-domaines

- **Domaine** : sujet ou activit√© sur laquelle l‚Äôapplication est construite.
- **Sous-domaine** : partie fonctionnelle sp√©cifique du domaine.

üí° *Dans notre cas :*

- **Domaine principal (Core Domain)** : *Vente de chaussures en ligne (HiShoes)*
- **Sous-domaines identifi√©s** :
    - Gestion des commandes (Order)
    - Livraison (Shipping)
    - üí° *Nouveau :* Facturation (Billing)

‚ö† **Remarque :**

üëâ La d√©termination des sous-domaines ne doit pas se faire uniquement c√¥t√© technique. Elle doit √™tre r√©alis√©e **en groupe**, avec les experts m√©tier.

üëâ C‚Äôest un **processus it√©ratif** : on ajuste au fur et √† mesure que la compr√©hension du domaine √©volue.

### Objectif p√©dagogique

‚úÖ Comprendre et d√©finir les concepts m√©tier essentiels pour √©tablir une langue commune qui :

- refl√®te fid√®lement la r√©alit√© du domaine,
- servira de socle √† la mod√©lisation et au code.

### Actions pratiques

üí¨ *Mets-toi dans la peau d‚Äôun d√©veloppeur assistant √† une r√©union avec l‚Äô√©quipe Facturation.*

‚û° L‚Äô√©quipe m√©tier √©voque des termes comme :

- `Commande`
- `Facture`
- `Montant`
- `Paiement`

üìù **Ta mission :**

1Ô∏è‚É£ Interroge-les pour **comprendre ce que chaque terme signifie dans leur contexte**.

2Ô∏è‚É£ R√©dige des **d√©finitions claires et simples** (sans jargon technique), comme si tu devais les expliquer √† une nouvelle recrue.

3Ô∏è‚É£ Conserve ces d√©finitions comme r√©f√©rence. Elles guideront toute la suite (mod√®le, code, documentation).

### Concepts DDD impliqu√©s

- **Langue d‚Äôubiquit√© (Ubiquitous Language)** :

  Un vocabulaire partag√© entre d√©veloppeurs et experts m√©tier.

  üìå Utilis√© dans la communication, la documentation et directement dans le code.

  üìå R√©duit les malentendus et aligne le logiciel sur la r√©alit√© m√©tier.

- **Collaboration √©troite** :

  Les d√©veloppeurs et experts m√©tier doivent travailler ensemble pour :

    - comprendre les besoins,
    - identifier les concepts cl√©s,
    - construire un mod√®le fid√®le au r√©el.

## √âtape 2 : Identifier les cas d‚Äôutilisation m√©tier

### Contexte

Maintenant que tu as particip√© √† l‚Äô√©laboration d‚Äôun vocabulaire partag√© (la langue d‚Äôubiquit√©), tu es pr√™t √† t‚Äôint√©resser aux **cas d‚Äôutilisation m√©tier** du sous-domaine *Facturation*.

üëâ Pourquoi c‚Äôest important‚ÄØ?

Les cas d‚Äôutilisation permettent de :

- comprendre **ce que fait r√©ellement le syst√®me pour le m√©tier** ;
- identifier **les actions majeures que le domaine doit supporter** ;
- poser les bases des futurs mod√®les, services et interfaces du syst√®me.

Les cas d‚Äôutilisation sont les **sc√©narios concrets** qui traduisent les besoins m√©tier en actions pr√©cises que le logiciel doit r√©aliser.

### Pourquoi identifier les cas d‚Äôutilisation dans une approche DDD‚ÄØ?

En Domain-Driven Design :

- On part du **besoin m√©tier** (et non de la technologie) ;
- On d√©crit ce que le domaine doit accomplir (sans se pr√©cipiter dans le ¬´‚ÄØcomment‚ÄØ¬ª) ;
- Ces cas d‚Äôutilisation guident la conception de notre mod√®le, nos services et nos interfaces (ports).

üëâ C‚Äôest une √©tape charni√®re entre le **Strategic Design** et le **Tactical Design**.

> **Astuce :
Imaginez que votre mission est de fabriquer un v√©lo simple et fonctionnel. Si vous commencez √† y ajouter des moteurs, des GPS, et des ailes, vous finissez avec une fus√©e. R√©sultat ? Beaucoup d‚Äôefforts pour quelque chose de disproportionn√© et inutilisable par rapport au besoin initial. üö≤‚ÜíüöÄ**
>

### Exemple dans HiShoes ‚Äî Sous-domaine Facturation

Dans le sous-domaine *Facturation*, gr√¢ce √† la collaboration avec les experts m√©tier, tu as identifi√© que le syst√®me doit :

1Ô∏è‚É£ **Cr√©er une facture pour chaque commande valid√©e**

2Ô∏è‚É£ **Encaisser un paiement pour une facture**

üí° Ces deux cas d‚Äôutilisation sont essentiels au fonctionnement du sous-domaine Billing.

Ils traduisent des actions r√©elles que l‚Äôentreprise effectue, et que ton logiciel doit permettre de r√©aliser.

### Objectif p√©dagogique de l‚Äô√©tape

‚úÖ Savoir **rep√©rer les cas d‚Äôutilisation √† partir des √©changes m√©tier**.

‚úÖ √ätre capable de **les exprimer clairement**, dans un langage accessible et partag√©.

‚úÖ Pr√©parer le terrain pour mod√©liser les entit√©s et les r√®gles m√©tiers (prochaine √©tape).

### Concepts DDD impliqu√©s

- **Cas d‚Äôutilisation m√©tier** : Ce sont les sc√©narios qui d√©crivent ce que le domaine doit permettre au m√©tier de faire. Ils refl√®tent les objectifs m√©tier, pas les d√©tails techniques.
- **Alignement m√©tier-technique** : Les cas d‚Äôutilisation garantissent que le syst√®me est con√ßu **pour servir les objectifs r√©els de l‚Äôentreprise**.

### **Actions pratiques**

üí¨ **Imagine la sc√®ne :**

Tu es en atelier avec les responsables du service facturation. Ils t‚Äôexpliquent comment ils travaillent.

Ton r√¥le : √©couter, poser des questions, et **traduire ce que tu entends en cas d‚Äôutilisation**.

### üéØ **M√©thodologie pour identifier les cas d‚Äôutilisation**

1Ô∏è‚É£ **Rep√®re les verbes d‚Äôaction dans les √©changes m√©tier**

> Ex : ‚ÄúQuand une commande est valid√©e, on g√©n√®re une facture.‚Äù,
>
>
> *‚ÄúQuand le client paie, on met √† jour le statut de la facture.‚Äù*
>

2Ô∏è‚É£ **Formule les cas d‚Äôutilisation sous forme de phrase :**

> En tant que [acteur du domaine], je veux [action], afin de [but m√©tier].
>

Exemples :

- *En tant que gestionnaire de facturation, je veux cr√©er une facture pour une commande valid√©e afin de r√©clamer le paiement au client.*
- *En tant que syst√®me de facturation, je veux enregistrer un paiement afin de mettre √† jour le statut de la facture.*

3Ô∏è‚É£ **V√©rifie que le cas d‚Äôutilisation est m√©tier et pas technique.**

> üëâ Ce n‚Äôest pas ‚ÄúPersister la facture dans la base‚Äù (√ßa, c‚Äôest technique).
>
>
> üëâ C‚Äôest *‚ÄúCr√©er une facture pour une commande valid√©e‚Äù* (√ßa, c‚Äôest m√©tier).
>

4Ô∏è‚É£ **Documente les cas d‚Äôutilisation dans un format simple et clair.**

### **Pi√®ges √† √©viter**

‚ùå M√©langer cas d‚Äôutilisation m√©tier et d√©tails techniques (ex : ‚Äúenregistrer en base‚Äù, ‚Äúexposer un endpoint HTTP‚Äù).

‚ùå D√©crire des cas trop vagues ou trop g√©n√©riques (ex : ‚ÄúG√©rer les factures‚Äù : trop large, trop impr√©cis).

‚ùå Oublier de valider les cas d‚Äôutilisation avec le m√©tier.

## **√âtape 3 : Conceptualiser le mod√®le du domaine**

### **Contexte**

√Ä ce stade :

‚úÖ Tu as √©tabli une langue d‚Äôubiquit√©.

‚úÖ Tu as identifi√© les cas d‚Äôutilisation m√©tier (par exemple : cr√©er une facture, encaisser un paiement).

üëâ **Prochaine √©tape : concevoir le mod√®le du domaine qui refl√®te fid√®lement ces cas d‚Äôutilisation et les r√®gles m√©tier.**

### **Pourquoi mod√©liser le domaine en DDD‚ÄØ?**

En Domain-Driven Design, le mod√®le du domaine est :

- **le c≈ìur de ton application** : il repr√©sente les concepts, r√®gles et comportements du m√©tier ;
- **ind√©pendant de la technique** : ce mod√®le ne parle pas de base de donn√©es, de REST API ou de frameworks, il parle uniquement du m√©tier ;
- **le reflet de la r√©alit√© m√©tier** : il sert de pont entre les experts m√©tier et le code.

üëâ **Un bon mod√®le de domaine aide √† √©crire un code qui ‚Äúparle m√©tier‚Äù** et qui reste lisible, maintenable et align√© sur les besoins r√©els.

### **Objectif p√©dagogique de l‚Äô√©tape**

‚úÖ Identifier les **√©l√©ments cl√©s du mod√®le** :

- **Entit√©s**
- **Objets de valeur**
- **Agr√©gats**

‚úÖ D√©finir leurs r√¥les et responsabilit√©s.

‚úÖ Poser les bases d‚Äôun mod√®le coh√©rent qui servira √† impl√©menter les cas d‚Äôutilisation.

### **M√©thodologie pour conceptualiser le mod√®le**

### 1Ô∏è‚É£ **Identifier les concepts m√©tier stables et distincts**

üí¨ √Ä partir des cas d‚Äôutilisation et de la langue d‚Äôubiquit√©, liste les concepts stables du domaine :

Exemple dans Facturation :

- **Facture**
- **Ligne de facture**
- **Montant**
- **Paiement**
- **Identifiant de facture**

### 2Ô∏è‚É£ **Classer ces concepts**

üëâ **Entit√©** : poss√®de une identit√© unique et persiste dans le temps, m√™me si ses attributs changent.

üëâ **Objet de valeur (Value Object)** : ne poss√®de pas d‚Äôidentit√© propre, est d√©fini uniquement par ses attributs.

üëâ **Agr√©gat** : racine du mod√®le. Regroupe un ensemble coh√©rent d‚Äôentit√©s et d‚Äôobjets de valeur avec des invariants m√©tier.

### 3Ô∏è‚É£ **D√©finir les relations**

- Quelle est l‚Äôentit√© principale (agr√©gat racine)‚ÄØ?
- Quels objets sont contenus dans cette entit√©‚ÄØ?
- Quelles sont les r√®gles d‚Äôint√©grit√© qui lient ces objets‚ÄØ?

### **R√©sultat attendu**

‚úÖ Un sch√©ma simple (papier, diagramme mermaid, UML l√©ger) du mod√®le du domaine.

‚úÖ Une description des r√¥les de chaque √©l√©ment identifi√©.

### **Pi√®ges √† √©viter pour un d√©butant**

‚ùå Tout transformer en entit√© par d√©faut : commence par des objets de valeur quand c‚Äôest possible (ex : `TotalAmount`, `InvoiceId`).

‚ùå Concevoir des relations trop fines entre agr√©gats : un agr√©gat doit √™tre autonome pour garantir la coh√©rence de ses r√®gles m√©tier.

‚ùå Lier trop t√¥t aux d√©tails techniques (base de donn√©es, API, etc.).

## √âtape 4 : Impl√©mentation du mod√®le

### **Contexte**

üëâ Tu as travaill√© sur la conceptualisation du mod√®le de ton domaine : tu as identifi√© les **entit√©s**, les **objets de valeur**, et les **agr√©gats** (par exemple : `Invoice` comme agr√©gat racine).

üëâ Tu as aussi d√©fini les **r√®gles m√©tier** que ce mod√®le doit faire respecter (par exemple : *¬´ une facture doit contenir au moins une ligne ¬ª*, *¬´ la somme des paiements ne peut pas d√©passer le montant d√ª ¬ª*).

üí° Il est temps de **passer du mod√®le conceptuel au code**, en respectant les principes du DDD.

### **Pourquoi impl√©menter le mod√®le avant tout autre chose ?**

Dans une architecture DDD :

‚úÖ Le mod√®le du domaine est au centre : tout part de lui.

‚úÖ C‚Äôest ce mod√®le qui contient la **logique m√©tier** et **garantit les r√®gles de l‚Äôentreprise**.

‚úÖ Il doit √™tre ind√©pendant de la technique : il ne sait rien des bases de donn√©es, frameworks, REST, etc.

üëâ Tu construis d‚Äôabord un mod√®le **pur m√©tier**, qui sera utilis√© par les services, les cas d‚Äôutilisation, et les ports.

### **Objectif p√©dagogique**

‚úÖ Traduire le mod√®le du domaine en **code m√©tier clair et riche**, sans d√©pendance technique.

‚úÖ Mettre en ≈ìuvre les r√®gles m√©tier directement dans les m√©thodes des entit√©s et des objets de valeur.

‚úÖ Pr√©parer un mod√®le facilement testable et √©volutif.

### **Exercice pratique et m√©thodologie**

üëâ √Ä partir du mod√®le conceptuel :

1Ô∏è‚É£ Impl√©mente les objets de valeur (`InvoiceId`, `Money`, `TotalAmount`).

2Ô∏è‚É£ Impl√©mente l‚Äôagr√©gat `Invoice` avec ses r√®gles m√©tier.

3Ô∏è‚É£ Ajoute des tests unitaires simples pour :

- cr√©er une facture valide,
- emp√™cher une facture vide,
- ajouter un paiement correct,
- refuser un paiement qui d√©passe le montant d√ª.

üëâ **Chaque √©l√©ment du mod√®le (entit√©, agr√©gat, objet de valeur) est responsable de garantir sa propre coh√©rence. Il doit v√©rifier lui-m√™me que ce qu‚Äôon lui demande respecte les r√®gles m√©tier.**

üëâ **Dans un mod√®le DDD, les invariants m√©tier sont prot√©g√©s au sein du mod√®le lui-m√™me : ce sont les entit√©s, agr√©gats et objets de valeur qui font respecter les r√®gles, et non le code ext√©rieur.**

### **Pi√®ges √† √©viter**

‚ùå Se contenter de getters / setters sans logique m√©tier : un mod√®le DDD doit **porter les r√®gles du domaine**.

‚ùå Introduire trop t√¥t des d√©pendances techniques (JPA annotations, ORM, API...).

‚ùå Oublier de tester les r√®gles m√©tier (par ex : sur un paiement qui d√©passe le montant d√ª).

## √âtape 5 : Cr√©ation des services du domaine

### **Contexte**

üëâ Tu as maintenant un **mod√®le du domaine solide** :

- Tes entit√©s et objets de valeur garantissent leurs invariants.
- Ton agr√©gat (par exemple `Invoice`) encapsule les r√®gles m√©tier principales.

üí° **Prochaine √©tape : cr√©er des services du domaine pour g√©rer la logique m√©tier qui :**
- n‚Äôa pas naturellement sa place dans une entit√© ou un agr√©gat, 
- concerne plusieurs objets du mod√®le, 
- repr√©sente des actions m√©tier ¬´ de plus haut niveau ¬ª.

### **Pourquoi cr√©er des services de domaine en DDD ?**

En DDD :

‚û° Les **domain services** portent des op√©rations m√©tier importantes qui :

- ne concernent pas qu‚Äôun seul agr√©gat ;
- ou qui expriment un processus m√©tier sans √©tat propre (stateless).

‚û° Le **service du domaine** est une fa√ßon de **nommer et isoler une action m√©tier** dans le code, sans d√©naturer les entit√©s.

üí¨ *Un service du domaine est comme un op√©rateur m√©tier ext√©rieur qui orchestre les agr√©gats pour accomplir un but m√©tier.*

### **Objectif p√©dagogique**

‚úÖ Comprendre ce qu‚Äôest un service de domaine et quand l‚Äôutiliser.

‚úÖ Savoir identifier la logique m√©tier qui m√©rite d‚Äô√™tre plac√©e dans un service.

‚úÖ Cr√©er un service du domaine propre, sans d√©pendances techniques.

### **Quand cr√©er un service de domaine ?**

üí° Crit√®res :

- L‚Äôop√©ration n‚Äôest pas naturellement attach√©e √† une entit√© ou un agr√©gat.
- L‚Äôop√©ration exprime une **action m√©tier** (pas technique).
- Le service manipule un ou plusieurs agr√©gats, mais ne porte pas d‚Äô√©tat propre durable.

### **Passer √† la pratique : Facturation de HiShoes**

üëâ Cr√©e un service du domaine qui :

Avant de te lancer, prends le temps de r√©fl√©chir aux informations, dont ton service √† avoir besoin pour transformer une commande en Facture.
Dans l'√©tape suivante, nous ferons un peu de refactoring pour am√©liorer encore notre d√©coupage des responsabilit√©s.

1Ô∏è‚É£ qui impl√©mente ton cas d'utilisation et prend une commande valid√©e,

2Ô∏è‚É£ g√©n√®re une facture et la sauvegarde,

3Ô∏è‚É£ respecte les r√®gles m√©tier (pas de facture vide, calcul des totaux).

üëâ √âcris un test unitaire :

- Donne-lui un mock d‚Äô`OrderService` et un `InvoiceRepository` in-memory ;
- V√©rifie qu‚Äôil produit une facture valide.

### **R√©sultat attendu**

‚úÖ Un service du domaine qui :

- a un nom qui refl√®te clairement l‚Äôaction m√©tier (par ex. `BillingDomainService`) ;
- ne porte pas d‚Äô√©tat propre ;
- appelle le mod√®le du domaine pour accomplir des actions m√©tier ;
- peut √™tre test√© ind√©pendamment des couches techniques.

### **Pi√®ges √† √©viter pour un d√©butant**

‚ùå Utiliser un service de domaine pour des actions purement techniques (ex : persister en base, exposer un endpoint).

‚ùå Mettre de la logique m√©tier essentielle **en dehors** des entit√©s/agr√©gats quand elle leur appartient.

‚ùå Transformer le service en *god object* qui fait tout au lieu de d√©l√©guer au mod√®le.

## √âtape 6 : Impl√©mentation des cas d‚Äôutilisation ‚Äî Pattern Command / Query

üëâ √Ä ce stade :

‚úÖ Tu as un mod√®le du domaine solide, avec des entit√©s, des agr√©gats et des services du domaine qui encapsulent la logique m√©tier.

‚úÖ Tu as identifi√© les cas d‚Äôutilisation m√©tier (ex : cr√©er une facture, encaisser un paiement).

üí° Maintenant, tu vas **organiser le code pour ex√©cuter ces cas d‚Äôutilisation** dans un style propre, coh√©rent et facile √† maintenir.

### **Pourquoi utiliser un pattern Command / Query ?**

Dans une architecture DDD + hexagonale :

‚û° **Les cas d‚Äôutilisation sont des actions m√©tier que le syst√®me propose au monde ext√©rieur (adaptateurs entrants)**.

‚û° Le **pattern Command/Query** permet de :

‚úÖ s√©parer les actions (Command : qui modifient l‚Äô√©tat) des lectures (Query : qui consultent sans effet de bord),

‚úÖ √©crire un code clair, align√© sur les intentions m√©tier,

‚úÖ faciliter les tests et l‚Äô√©volution.

üí¨ *Un cas d‚Äôutilisation = un sc√©nario m√©tier exprim√© sous forme d‚Äôun handler Command ou Query.*

### **Objectif p√©dagogique**

‚úÖ Organiser le code autour de cas d‚Äôutilisation clairs et ind√©pendants de la technique.

‚úÖ Appliquer Command pour les actions m√©tier (ex : cr√©er une facture).

‚úÖ Appliquer Query pour les lectures (ex : retrouver une facture par son ID).

### üåü **Explication du pattern Command / Query dans le contexte DDD**

Dans un syst√®me orient√© DDD et architecture hexagonale, on distingue :

- les **Commandes (Commands)** : elles expriment une **intention**.
- les **Requ√™tes (Queries)** : elles r√©cup√®rent des **informations** sans modifier l‚Äô√©tat du syst√®me.

### **Command : exprimer une intention**

üëâ Une commande repr√©sente **l‚Äôaction qu‚Äôun utilisateur ou un syst√®me externe veut demander au domaine**.

üëâ La Command :

- porte les **donn√©es n√©cessaires** pour accomplir cette action (par ex : identifiant de commande, montant du paiement) ;
- **demande au domaine d‚Äôagir**, en respectant les r√®gles m√©tier.

üí° Exemples :

- *CreateInvoiceCommand* : *¬´ Je veux cr√©er une facture pour cette commande ¬ª*.
- *PayInvoiceCommand* : *¬´ Je veux enregistrer un paiement de ce montant sur cette facture ¬ª*.

La Command ne d√©crit pas *comment* l‚Äôaction sera r√©alis√©e, elle **exprime l‚Äôintention** √† transmettre au domaine et √† l‚Äôapplication.

### **Query : fournir des informations pour guider une d√©cision**

üëâ Une requ√™te repr√©sente **un besoin de lecture**, pour obtenir des donn√©es qui aideront l‚Äôutilisateur (ou un syst√®me) √† **prendre une d√©cision**.

üëâ La Query :

- **prend des crit√®res** (ex : identifiant de facture) ;
- **renvoie un r√©sultat** (ex : les d√©tails d‚Äôune facture).

üí° Exemple :

- *GetInvoiceByIdQuery* : *¬´ Donne-moi les informations sur cette facture ¬ª*.

Ces informations permettront √† l‚Äôutilisateur de :

üëâ *¬´ Voir ce qui reste √† payer ¬ª* ‚Üí puis exprimer une intention via une commande (*PayInvoiceCommand*).

### **Vision compl√©mentaire : le dialogue Command / Query**

üëâ **La Query permet √† l‚Äôutilisateur de comprendre l‚Äô√©tat du syst√®me pour formuler ensuite une Command qui exprime une intention.**

üëâ **La Command est la mat√©rialisation de cette intention, que l‚Äôapplication et le domaine vont traiter pour agir.**

### **Pourquoi ce pattern est utile ?**

‚úÖ Il clarifie les responsabilit√©s :

- **Query = lecture (aucun effet de bord)**
- **Command = √©criture (modifie l‚Äô√©tat du syst√®me)**

‚úÖ Il favorise un code plus lisible, testable, √©volutif.

‚úÖ Il aide √† aligner le code sur le langage m√©tier (Ubiquitous Language).

### **Exercice pratique**

üëâ Impl√©mente :

1Ô∏è‚É£ `CreateInvoiceCommand` + `CreateInvoiceCommandHandler`.

2Ô∏è‚É£ `PayInvoiceCommand` + `PayInvoiceCommandHandler` (avec logique pour ajouter un paiement).

3Ô∏è‚É£ `GetInvoiceByIdQuery` + `QueryHandler`.

> Un Handler peut aussi et est souvent appel√© UseCase. On peut tout √† fait imaginer renommer `CreateInvoiceCommandHandler` en `CreateInvoiceCommandUseCase`.


üëâ √âcris un test :

- Tu passes un Command, tu verifies que l‚Äôagr√©gat a bien √©t√© cr√©√© / modifi√©.
- Tu passes un Query, tu verifies que les bonnes donn√©es sont retourn√©es.

### **R√©sultat attendu**

‚úÖ Un code qui exprime clairement les intentions m√©tier :

- *¬´ Je veux cr√©er une facture ¬ª* ‚Üí Command + Handler
- *¬´ Je veux retrouver une facture ¬ª* ‚Üí Query + Handler

‚úÖ Une s√©paration des responsabilit√©s :

- Les **CommandHandlers** ne font que modifier l‚Äô√©tat.
- Les **QueryHandlers** ne font que lire l‚Äô√©tat.

### **Pi√®ges √† √©viter**

‚ùå M√©langer lecture et √©criture dans un m√™me handler.

‚ùå Laisser les CommandHandlers g√©rer des d√©tails techniques (ex : transaction, persistance directe).

‚ùå Injecter des adaptateurs techniques (ex : base de donn√©es, frameworks) directement dans les Command : les Command restent des objets simples.

## **√âtape 7 : Ports et adaptateurs sortants**

### **Contexte**

üëâ Tu as d√©sormais :

‚úÖ Un mod√®le m√©tier riche (entit√©s, objets de valeur, agr√©gats)

‚úÖ Des services du domaine qui orchestrent les actions

‚úÖ Des cas d‚Äôutilisation clairs via le pattern Command / Query

üí° Prochaine √©tape : connecter ton domaine au reste du monde **sans le polluer avec des d√©tails techniques**.

C‚Äôest l√† qu‚Äôinterviennent les **ports** et **adaptateurs**, concepts essentiels de l‚Äô**architecture hexagonale** (ou **Ports & Adapters**).

### **Pourquoi des ports et adaptateurs ?**

En architecture hexagonale :

‚û° Le **domaine doit √™tre ind√©pendant des technologies ext√©rieures** (bases de donn√©es, API externes, syst√®mes tiers).

‚û° Le domaine **ne conna√Æt que des interfaces (ports)**.

‚û° Les **adaptateurs sortants** sont les impl√©mentations concr√®tes de ces interfaces, situ√©es dans les couches ext√©rieures.

üí¨ *Les ports d√©finissent ce dont le domaine a besoin, les adaptateurs r√©alisent concr√®tement ces besoins.*

### **Objectif p√©dagogique**

‚úÖ Savoir **d√©finir un port (interface)** exprimant un besoin du domaine.

‚úÖ Savoir **impl√©menter un adaptateur sortant** (ex : persistance, appel √† un syst√®me externe).

‚úÖ Respecter la **s√©paration des pr√©occupations** : le domaine ne sait rien des technologies.

### Passer √† la pratique

üëâ Cr√©e :

1Ô∏è‚É£ Un `InvoiceRepository` (port) dans le domaine.

2Ô∏è‚É£ Une impl√©mentation in-memory (en m√©moire, dans une HashMap par exemple).

3Ô∏è‚É£ (Facultatif) Une interface `PaymentProcessor` + un mock (pour tester).

üëâ √âcris un test qui :

- cr√©e une facture via le domaine + repository in-memory,
- v√©rifie que la facture est bien stock√©e et retrouv√©e.

### **R√©sultat attendu**

‚úÖ Le domaine ne conna√Æt que des interfaces (ports).

‚úÖ Les adaptateurs sont branch√©s de l‚Äôext√©rieur (via configuration, injection de d√©pendances).

‚úÖ Tu peux changer un adaptateur sans toucher au domaine (ex : passer de JPA √† Mongo sans modifier le mod√®le).

### **Pi√®ges √† √©viter pour un d√©butant**

‚ùå Lier directement le domaine √† une technologie (ex : mettre des annotations JPA sur tes entit√©s de domaine).

‚ùå Faire des adaptateurs trop ¬´ intelligents ¬ª qui r√©√©crivent la logique m√©tier : c‚Äôest le r√¥le du domaine.

‚ùå Oublier d‚Äô√©crire des impl√©mentations simples (in-memory) pour faciliter les tests.

## **√âtape finale : Assemblage et test de bout en bout**

### **Contexte**

üëâ Tu as con√ßu et cod√© :

‚úÖ Un mod√®le du domaine fid√®le au m√©tier (agr√©gats, entit√©s, objets de valeur).

‚úÖ Des services du domaine qui orchestrent la logique m√©tier.

‚úÖ Des cas d‚Äôutilisation via des Command / Query Handlers.

‚úÖ Des ports et adaptateurs qui connectent ton domaine au reste du monde.

üí° **L‚Äô√©tape finale consiste √† assembler ces √©l√©ments, les relier via des adaptateurs entrants (par exemple un contr√¥leur REST), et valider l‚Äôensemble avec des tests.**

### **Objectif p√©dagogique**

‚úÖ Comprendre comment connecter les couches sans casser les principes de l‚Äôarchitecture hexagonale.

‚úÖ V√©rifier que le domaine fonctionne comme pr√©vu lorsqu‚Äôil est sollicit√© via un adaptateur entrant.

‚úÖ Valider le flux m√©tier complet : **du client √† la persistance, en passant par le domaine**.

# ü™∂ **R√©sultat attendu ou proposition de compr√©hension du domaine m√©tier de l‚Äôentreprise**

>**Retrouve une proposition d'impl√©mentation compl√®te dans le package `billing.implementation.exemple` du projet.**
> 
> **Et ci-dessous des explications √©tapes par √©tapes ;)**
> 
> Il se peut que certains exemples ici diff√®re du code que vous trouverez dans le projet. Il s'agit de diff√©rents exemples d'impl√©mentation.

## √âtape 1 : Comprendre l‚Äôimportance de la collaboration et de la langue d‚Äôubiquit√© (Strategic Design)

‚úÖ Un mini-glossaire des concepts essentiels du sous-domaine Facturation :

Par exemple :

| Terme    | D√©finition partag√©e                                                  |
|----------|----------------------------------------------------------------------|
| Commande | Une demande formelle d‚Äôun client d‚Äôacheter un ou plusieurs articles. |
| Facture  | Document √©mis suite √† une commande valid√©e, pr√©cisant le montant d√ª. |
| Montant  | La somme √† payer par le client pour r√©gler sa facture.               |
| Paiement | L‚Äôaction de r√©gler une facture en partie ou en totalit√©.             |

## √âtape 2 : Identifier les cas d‚Äôutilisation m√©tier

### **Cas d‚Äôutilisation identifi√©s pour HiShoes ‚Äî Facturation**

| Cas d‚Äôutilisation | Acteur principal                   | Description m√©tier                                                                                                                    |
|-------------------|------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|
| Cr√©er une facture | Gestionnaire Facturation / Syst√®me | G√©n√©rer une facture d√®s qu'une commande est valid√©e. La facture indique les articles, le prix, les taxes et le montant total √† payer. |
| Payer une facture | Client / Syst√®me                   | Enregistrer un paiement effectu√© par le client, v√©rifier que le montant couvre ce qui est d√ª, et changer le statut de la facture.     |

---

### **R√©sultat attendu**

‚úÖ Une **liste claire des cas d‚Äôutilisation du sous-domaine Facturation**, exprim√©e dans un langage m√©tier.

‚úÖ Ces cas d‚Äôutilisation doivent √™tre valid√©s avec les experts m√©tier (par exemple lors d‚Äôune revue ou d‚Äôun atelier).

‚úÖ Ils serviront de base pour :

- conceptualiser le mod√®le du domaine (prochaine √©tape) ;
- concevoir les services et les interfaces.

### **Exemple de cas d‚Äôutilisation : Cr√©er une facture pour une commande valid√©e**

### **Nom du cas d‚Äôutilisation**

Cr√©er une facture pour une commande valid√©e

### **Objectif**

G√©n√©rer une facture associ√©e √† une commande d√®s qu‚Äôelle est valid√©e.

La facture contient les d√©tails de la commande, le montant total, les taxes et le statut initial `EN_ATTENTE`.

### **Acteurs principaux**

- **Syst√®me de gestion des commandes** (Order Management System) : d√©clencheur du cas d‚Äôutilisation.
- **Service de facturation (Billing)** : r√©alise l‚Äôaction.
- **Client** (indirectement concern√© : destinataire de la facture).

### **Pr√©-condition**

- La commande existe et son statut est `VALID√âE`.

### **D√©clencheur**

- Le syst√®me de gestion des commandes notifie le module Facturation qu'une commande a √©t√© valid√©e.

### **Description du sc√©nario principal**

1Ô∏è‚É£ Le syst√®me de gestion des commandes envoie un message avec l‚Äôidentifiant de la commande valid√©e.

2Ô∏è‚É£ Le module Facturation r√©cup√®re les d√©tails de la commande (lignes de commande, montant, taxes).

3Ô∏è‚É£ Le module Facturation calcule le montant total de la facture.

4Ô∏è‚É£ Le module cr√©e une facture avec un identifiant unique, les lignes, le montant total et le statut `EN_ATTENTE`.

5Ô∏è‚É£ La facture est persist√©e dans le syst√®me de facturation.

6Ô∏è‚É£ La facture est rendue disponible pour consultation (par exemple via un portail client ou un envoi par email).

### **R√®gles m√©tier**

‚úÖ Chaque commande valid√©e doit donner lieu √† une seule facture.

‚úÖ La facture initiale a toujours un statut `EN_ATTENTE`.

‚úÖ Le montant de la facture correspond au total des lignes de commande + taxes.

‚úÖ La facture garde la trace de l'identifiant de la commande.

### **Exceptions**

‚ùå La commande n‚Äôexiste pas ‚Üí Le syst√®me logge une erreur et rejette l‚Äôop√©ration.

‚ùå Une facture existe d√©j√† pour cette commande ‚Üí Le syst√®me rejette la cr√©ation d‚Äôune nouvelle facture.

### **Post-condition**

Une facture est cr√©√©e, associ√©e √† la commande valid√©e, et stock√©e.

### **Donn√©es manipul√©es**

- Commande : ID, lignes (produit, quantit√©, prix unitaire), montant.
- Facture : ID, r√©f√©rence commande, lignes, montant total, statut.

### **Langue d‚Äôubiquit√© utilis√©e**

- Commande
- Facture
- Ligne de commande
- Montant total
- Statut de la facture (`EN_ATTENTE`)

### **√âtape 3 : Conceptualiser le mod√®le du domaine**

*Exemple : mod√®le de domaine Facturation HiShoes*

### Agr√©gat racine : **Facture (Invoice)**

- Entit√© principale qui repr√©sente la facture d‚Äôune commande.
- Poss√®de un **InvoiceId** (objet de valeur identifiant unique).
- Contient une liste de **InvoiceLine** (lignes de facture).
- Contient un **TotalAmount** (objet de valeur repr√©sentant le montant total avec taxes).
- Poss√®de un **status** : EN_ATTENTE, PAYEE, EN_RETARD.
- Conna√Æt ses paiements (par exemple sous forme d‚Äôune collection d‚Äôenregistrements de paiements).

### Entit√©s et objets de valeur

| √âl√©ment               | Type                          | Raison                                                           |
|-----------------------|-------------------------------|------------------------------------------------------------------|
| **Facture (Invoice)** | Entit√©, agr√©gat racine        | A une identit√© propre (InvoiceId), persiste dans le temps        |
| **InvoiceId**         | Objet de valeur               | Identifie de fa√ßon unique la facture                             |
| **InvoiceLine**       | Entit√© ou VO selon complexit√© | Repr√©sente un article factur√© (produit, quantit√©, prix unitaire) |
| **TotalAmount**       | Objet de valeur               | Repr√©sente le montant d√ª, immuable une fois calcul√©              |
| **Paiement**          | Entit√© ou √©v√®nement m√©tier    | Enregistrement d‚Äôun r√®glement partiel ou total de la facture     |

### **R√®gles m√©tier int√©gr√©es au mod√®le**

‚úÖ Une facture conna√Æt son statut et g√®re elle-m√™me le changement de statut en fonction des paiements re√ßus.

‚úÖ La somme des paiements ne peut pas d√©passer le montant d√ª.

‚úÖ Une facture doit contenir au moins une ligne.

‚úÖ Les objets de valeur (`TotalAmount`, `InvoiceId`) sont immuables : leur contenu ne change pas une fois cr√©√©.

## √âtape 4 : Impl√©mentation du mod√®le

### 1Ô∏è‚É£ **Commence par les objets de valeur**

üí¨ Ce sont des petits objets, immuables, souvent tr√®s simples √† coder.

Exemple :

```java
public record InvoiceId(String value) {
    public InvoiceId {
        if (value == null || value.isBlank()) {
            throw new IllegalArgumentException("InvoiceId cannot be null or blank");
        }
    }
}

```

üëâ Ici on utilise `record` en Java, `record struct` en C#, `type` ou `class` immuable en TypeScript.

### 2Ô∏è‚É£ **Code l‚Äôagr√©gat racine**

üí¨ L‚Äôagr√©gat racine doit :

- garantir les invariants m√©tier ;
- exposer des m√©thodes m√©tier (pas juste des getters / setters).

Exemple :

```java
public class Invoice {
    private final InvoiceId id;
    private final List<InvoiceLine> lines;
    private final TotalAmount totalAmount;
    private final List<PaymentDetail> payments = new ArrayList<>();
    private InvoiceStatus status;

    public Invoice(InvoiceId id, List<InvoiceLine> lines, TotalAmount totalAmount) {
        if (lines == null || lines.isEmpty()) {
            throw new IllegalArgumentException("Invoice must have at least one line");
        }
        this.id = id;
        this.lines = List.copyOf(lines);
        this.totalAmount = totalAmount;
        this.status = InvoiceStatus.PENDING;
    }

    public void addPayment(PaymentDetail payment) {
        if (getPaidAmount().plus(payment.amount()).isGreaterThan(totalAmount)) {
            throw new IllegalStateException("Payment exceeds total amount due");
        }
        payments.add(payment);
        if (getPaidAmount().equals(totalAmount)) {
            this.status = InvoiceStatus.PAID;
        }
    }

    private Money getPaidAmount() {
        return payments.stream()
                       .map(Payment::amount)
                       .reduce(Money::plus)
                       .orElse(Money.zero(totalAmount.currency()));
    }

    public InvoiceStatus getStatus() {
        return status;
    }
}

```

üí° Ici, l‚Äôagr√©gat :

- g√®re lui-m√™me son √©tat (statut),
- v√©rifie les r√®gles m√©tier (ex : ne pas d√©passer le montant d√ª).

### 3Ô∏è‚É£ **Impl√©mente les autres entit√©s / VO**

Exemple pour `InvoiceLine` :

```java
public record InvoiceLine(String productId, String description, int quantity, Money unitPrice) {
    public InvoiceLine {
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive");
        }
    }

    public Money lineTotal() {
        return unitPrice.multiply(quantity);
    }
}

```

Et pour `Money` (objet de valeur) :

```java
public record Money(BigDecimal amount, String currency) {
    public Money {
        if (amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }
    }

    public Money plus(Money other) {
        checkSameCurrency(other);
        return new Money(this.amount.add(other.amount), this.currency);
    }

    public Money multiply(int multiplier) {
        return new Money(this.amount.multiply(BigDecimal.valueOf(multiplier)), this.currency);
    }

    public boolean isGreaterThan(Money other) {
        checkSameCurrency(other);
        return this.amount.compareTo(other.amount) > 0;
    }

    public boolean equals(Money other) {
        checkSameCurrency(other);
        return this.amount.compareTo(other.amount) == 0;
    }

    private void checkSameCurrency(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new IllegalArgumentException("Currency mismatch");
        }
    }

    public static Money zero(String currency) {
        return new Money(BigDecimal.ZERO, currency);
    }
}

```

## Notion importante : l‚Äôobjet est garant de son int√©grit√©

**Exemple : Facture et paiement dans HiShoes**

üëâ Imagine qu‚Äôon veuille ajouter un paiement √† une facture.

üëâ La r√®gle m√©tier dit : *¬´ On ne peut pas payer plus que le montant d√ª ¬ª*.

### **Mauvaise approche (la r√®gle est laiss√©e au code ext√©rieur)**

```java
// Service externe qui fait la v√©rification au lieu du mod√®le
if (payment.amount().isGreaterThan(invoice.getRemainingAmount())) {
    throw new IllegalStateException("Paiement trop √©lev√©");
}
invoice.getPayments().add(payment);
```

‚ö† Ici, la **logique m√©tier est dispers√©e** dans le code ext√©rieur. Le mod√®le n‚Äôa aucun contr√¥le sur ce qu‚Äôon lui ajoute.

### **Bonne approche (le mod√®le garantit lui-m√™me son int√©grit√©)**

```java
public void addPayment(Payment payment) {
    if (getPaidAmount().plus(payment.amount()).isGreaterThan(totalAmount)) {
        throw new IllegalStateException("Paiement d√©passe le montant d√ª");
    }
    this.payments.add(payment);
    if (getPaidAmount().equals(totalAmount)) {
        this.status = InvoiceStatus.PAID;
    }
}

```

‚úÖ Ici, c‚Äôest **l‚Äôagr√©gat `Invoice` qui impose la r√®gle**.

‚úÖ Impossible d‚Äôajouter un paiement invalide sans que le mod√®le ne le refuse.

‚úÖ Le mod√®le est **auto-coh√©rent** et prot√®ge les invariants du domaine.

üëâ *Le mod√®le est le gardien des r√®gles m√©tier. Si on lui demande une op√©ration invalide, il doit refuser directement, sans d√©pendre du code ext√©rieur.*

‚û° Le terme **invariant** vient des math√©matiques et de l‚Äôinformatique :

Un *invariant* d√©signe une propri√©t√© ou une r√®gle qui **doit rester vraie** tout au long de l‚Äôexistence d‚Äôun objet, malgr√© les op√©rations effectu√©es sur lui.

En g√©nie logiciel, on parle d‚Äôinvariants :

- en programmation orient√©e objet (OO) : des conditions que les instances d'une classe doivent toujours respecter ;
- en DDD : des r√®gles m√©tier qui doivent toujours √™tre vraies pour que le mod√®le soit coh√©rent.

üí° Par exemple :

> L'invariant d'une facture : le total des paiements ne peut pas d√©passer le montant d√ª.
>
>
> *L'invariant d'une ligne de commande : la quantit√© doit √™tre sup√©rieure √† z√©ro.*
>

Dans **Domain-Driven Design**, les **agr√©gats** sont sp√©cifiquement l√† pour :

‚úÖ prot√©ger les invariants du domaine ;

‚úÖ garantir qu‚Äôaucune op√©ration ne puisse briser ces r√®gles, m√™me en cas de traitement concurrent.

Eric Evans en parle dans son livre *Domain-Driven Design: Tackling Complexity in the Heart of Software* (2003).

Les invariants sont ce qui fait que ton mod√®le **reste valide et fid√®le au m√©tier, quelles que soient les manipulations faites dessus**.

## √âtape 5 : Cr√©ation des services du domaine

### **Exemple de code (Java / pseudo code simplifi√©)**

```java
public class BillingDomainService {

    private final InvoiceRepository invoiceRepository;
    private final OrderService orderService;

    public BillingDomainService(InvoiceRepository invoiceRepository, OrderService orderService) {
        this.invoiceRepository = invoiceRepository;
        this.orderService = orderService;
    }

    public Invoice createInvoiceForOrder(String orderId) {
        OrderDetails order = orderService.getOrderDetails(orderId);
        if (order == null) {
            throw new IllegalArgumentException("Order not found: " + orderId);
        }

        List<InvoiceLine> lines = order.toInvoiceLines();
        TotalAmount total = calculateTotal(lines);

        Invoice invoice = new Invoice(new InvoiceId(UUID.randomUUID().toString()), lines, total);
        invoiceRepository.save(invoice);
        return invoice;
    }

    private TotalAmount calculateTotal(List<InvoiceLine> lines) {
        Money total = lines.stream()
                           .map(InvoiceLine::lineTotal)
                           .reduce(Money::plus)
                           .orElseThrow(() -> new IllegalArgumentException("No lines provided"));
        return new TotalAmount(total);
    }
}

```

‚úÖ Ce service :

- **orchestration m√©tier** : il construit la facture √† partir de la commande.
- **pas d‚Äô√©tat propre** : il agit et rend un r√©sultat.
- **respect des r√®gles m√©tier** : c‚Äôest lui qui s‚Äôassure qu‚Äôon ne cr√©e une facture que pour une commande valide.

## √âtape 6 : Impl√©mentation des cas d‚Äôutilisation ‚Äî Pattern Command / Query

### **Structure type d‚Äôun cas d‚Äôutilisation**

üëâ Command (action)

```
+ Command : un objet simple qui contient les donn√©es n√©cessaires pour ex√©cuter l‚Äôaction.
+ CommandHandler : une classe qui ex√©cute l‚Äôaction, en utilisant le mod√®le et les services.

```

üëâ Query (lecture)

```
+ Query : un objet qui porte les crit√®res de recherche.
+ QueryHandler : une classe qui ex√©cute la lecture.

```

### **Exemple concret : cr√©er une facture (Command)**

### üìù **Command**

```java
public record CreateInvoiceCommand(String orderId) { }

```

‚û° Simple data holder : ce que l‚Äôappelant fournit.

### üìù **CommandHandler**

```java
public class CreateInvoiceCommandHandler {
    private final BillingDomainService billingDomainService;

    public CreateInvoiceCommandHandler(BillingDomainService billingDomainService) {
        this.billingDomainService = billingDomainService;
    }

    public Invoice handle(CreateInvoiceCommand command) {
        return billingDomainService.createInvoiceForOrder(command.orderId());
    }
}

```

‚úÖ Le **handler** est l‚Äôentr√©e de ton application c√¥t√© m√©tier : il orchestre l‚Äôappel au domaine.

### **Exemple concret : retrouver une facture (Query)**

### üìù **Query**

```java
public record GetInvoiceByIdQuery(String invoiceId) { }

```

### üìù **QueryHandler**

```java
public class GetInvoiceByIdQueryHandler {
    private final InvoiceRepository invoiceRepository;

    public GetInvoiceByIdQueryHandler(InvoiceRepository invoiceRepository) {
        this.invoiceRepository = invoiceRepository;
    }

    public Optional<Invoice> handle(GetInvoiceByIdQuery query) {
        return invoiceRepository.findById(new InvoiceId(query.invoiceId()));
    }
}

```

## √âtape 7 : Ports et adaptateurs sortants

### **Exemple concret : Facturation HiShoes**

### **Port : `InvoiceRepository`**

‚û° Le domaine a besoin de **sauvegarder et retrouver des factures**.

‚û° Il d√©clare un port (interface) :

```java
public interface InvoiceRepository {
    void save(Invoice invoice);
    Optional<Invoice> findById(InvoiceId id);
}

```

‚úÖ **Le domaine ne sait pas comment la facture est stock√©e** : base SQL, NoSQL, fichier, en m√©moire‚Ä¶ peu importe.

### **Port : `PaymentProcessor` (exemple optionnel)**

‚û° Si le domaine doit interagir avec un service externe pour valider un paiement :

```java
public interface PaymentProcessor {
    PaymentConfirmation process(PaymentRequest request);
}

```

### **Adaptateur sortant : une impl√©mentation de `InvoiceRepository`**

üëâ Exemple : un repository en m√©moire pour les tests

```java
public class InMemoryInvoiceRepository implements InvoiceRepository {
    private final Map<String, Invoice> store = new HashMap<>();

    @Override
    public void save(Invoice invoice) {
        store.put(invoice.getId().value(), invoice);
    }

    @Override
    public Optional<Invoice> findById(InvoiceId id) {
        return Optional.ofNullable(store.get(id.value()));
    }
}

```

üëâ Exemple : un repository avec une base SQL (dans la vraie app, en dehors du domaine pur)

```java
public class JpaInvoiceRepository implements InvoiceRepository {
    private final SpringDataInvoiceRepository jpaRepo;

    public JpaInvoiceRepository(SpringDataInvoiceRepository jpaRepo) {
        this.jpaRepo = jpaRepo;
    }

    @Override
    public void save(Invoice invoice) {
        jpaRepo.save(InvoiceEntityMapper.toEntity(invoice));
    }

    @Override
    public Optional<Invoice> findById(InvoiceId id) {
        return jpaRepo.findById(id.value())
                      .map(InvoiceEntityMapper::toDomain);
    }
}

```

## √âtape finale : Assemblage et test de bout en bout

### 1Ô∏è‚É£ **Adaptateurs entrants : exposer les cas d‚Äôutilisation**

üí¨ Exemple REST Controller pour cr√©er une facture :

```java
@RestController
@RequestMapping("/invoices")
public class InvoiceController {
    private final CreateInvoiceCommandHandler createHandler;
    private final GetInvoiceByIdQueryHandler queryHandler;

    public InvoiceController(CreateInvoiceCommandHandler createHandler,
                             GetInvoiceByIdQueryHandler queryHandler) {
        this.createHandler = createHandler;
        this.queryHandler = queryHandler;
    }

    @PostMapping
    public ResponseEntity<InvoiceDto> createInvoice(@RequestBody CreateInvoiceRequest req) {
        CreateInvoiceCommand cmd = new CreateInvoiceCommand(req.orderId());
        Invoice invoice = createHandler.handle(cmd);
        return ResponseEntity.ok(InvoiceDto.fromDomain(invoice));
    }

    @GetMapping("/{id}")
    public ResponseEntity<InvoiceDto> getInvoice(@PathVariable String id) {
        return queryHandler.handle(new GetInvoiceByIdQuery(id))
                .map(inv -> ResponseEntity.ok(InvoiceDto.fromDomain(inv)))
                .orElse(ResponseEntity.notFound().build());
    }
}

```

‚úÖ L‚Äôadaptateur entrant **ne contient pas de logique m√©tier** : il d√©l√®gue au Command/Query Handler.

### 2Ô∏è‚É£ **Assembler les ports et adaptateurs**

üí¨ Par exemple, via injection Spring ou instanciation manuelle en test :

```java
InvoiceRepository repo = new InMemoryInvoiceRepository();
OrderService orderService = new FakeOrderService();

BillingDomainService billingService = new BillingDomainService(repo, orderService);
CreateInvoiceCommandHandler createHandler = new CreateInvoiceCommandHandler(billingService);
GetInvoiceByIdQueryHandler queryHandler = new GetInvoiceByIdQueryHandler(repo);

```

üëâ Tu relies les ports √† leurs adaptateurs **sans toucher au domaine**.

### 3Ô∏è‚É£ **√âcrire un test de bout en bout**

üí¨ Exemple JUnit (ou √©quivalent dans un autre langage)

```java
@Test
void shouldCreateAndRetrieveInvoice() {
    // Assemblage du syst√®me
    InvoiceRepository repo = new InMemoryInvoiceRepository();
    OrderService orderService = new FakeOrderService();
    BillingDomainService billingService = new BillingDomainService(repo, orderService);
    CreateInvoiceCommandHandler createHandler = new CreateInvoiceCommandHandler(billingService);
    GetInvoiceByIdQueryHandler queryHandler = new GetInvoiceByIdQueryHandler(repo);

    // Command : cr√©ation
    CreateInvoiceCommand cmd = new CreateInvoiceCommand("order-123");
    Invoice createdInvoice = createHandler.handle(cmd);

    // Query : r√©cup√©ration
    Optional<Invoice> retrieved = queryHandler.handle(new GetInvoiceByIdQuery(createdInvoice.getId().value()));

    assertTrue(retrieved.isPresent());
    assertEquals(createdInvoice.getId(), retrieved.get().getId());
    assertEquals(InvoiceStatus.PENDING, retrieved.get().getStatus());
}

```

‚úÖ Ce test valide que le syst√®me complet fonctionne **sans infrastructure lourde (DB r√©elle)**.

# ü™∂ Evolutions
- Documentation th√©orique events de domaine 
- Exercice pratique th√©orique events de domaine
- Impl√©mentation des events de domaine 
- Mise en place de tests unitaires

# ü™∂ **Des questions ? Des retours ?**

Je serais ravie d‚Äô√©changer avec vous sur vos exp√©riences, vos questions, ou vos suggestions pour am√©liorer ce projet.

üìß **Contactez-moi** : Chlo√© Guilbaud

üîó **Retrouvez-moi sur LinkedIn** : [Chlo√© Guilbaud](https://www.linkedin.com/in/chloeguilbaud/)